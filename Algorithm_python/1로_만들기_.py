x = int(input(" 입력 !! :  "))

d = [0] * 11

for i in range(2, x + 1):
    # 1뺀다 쳤을 때, 1을 뺀다는건 1번의 연산을 한거니까 매번 일단 테이블에 1을 뺀단 가정으로 연산횟수 1 을 늘려주고 시작하기.
    # 거기 플러스 먄악 숫자가 2, 3, 5로 나눠떨어지지 않는다면 (예를들어 7) 연산을 할 필요없이, 그전 숫자인
    # 6이 몇번의 연산끝에 이루어졌는지 알고있으니까 이전 6의 연산횟수와 함께 7은 6보다 1 이 더 크니까 1을 빼야함으로
    # 해당 연산횟수까지 추가해서 테이블에 1을 더 플러스 해 주어 넣어주기!
    d[i] = d[i - 1] + 1

    # 여기서는 가장 최소 연산을 값으로 내뿜어야 됨으로, 비교를 해본다! min 으로 가장 숫자가 작은값을 최종적으로 테이블에 올리는데
    # 현재 d[i] 의 값은 단순히 내 이전 값의 연산횟수에 1을 한번더 뺀다는 연산횟수를 더한 +1 의 값이다.
    # 근데 이 값과, 만약 % 로 나누어ㅓ 떨어졌을 때, 2 또는 3, 5 로 나눈 값이 있는 테이블을 찾고, 해당 테이블의 연산횟수 값에
    # 1 을 더하여 준다. 왜냐하면 해당 테이블을 가기위한 연산이 이미 있기때문 ( ex, 10 이면 10//5 = 2 고 인덱스2의 테이블을 가서 2는 1회의
    # 연산을 가졌고, 1회 +1 을 한다는것은 내가 이미 10//5 라는연산을 한번 했기때문에 해당 연산 횟수를 더해주는것! )
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)
    print(d)

print(d[x])
